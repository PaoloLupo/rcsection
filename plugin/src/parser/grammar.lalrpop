use std::str::FromStr;
use crate::parser::ast::{Section, SectionType, SectionProperties, Shape, RebarEntry, RebarPattern, StirrupsConfig, Spacing, RawProperty, View};

grammar;

pub Sections: Vec<Section> = {
    <s:Section*> => s
};

Section: Section = {
    <k:SectionType> <id:StringLiteral> ":" "{" <s:Shape> <p:Properties> "}" => {
        let mut props = p;
        props.shape = Some(s);
        Section {
            kind: k,
            id: id,
            properties: props,
        }
    }
};

SectionType: SectionType = {
    "beam" => SectionType::Beam,
    "column" => SectionType::Column,
    "wall" => SectionType::Wall,
};

Properties: SectionProperties = {
    <props:RawProperty*> => {
        let mut shape = None;
        let mut cover = None;
        let mut span = None;
        let mut concrete = None;
        let mut rebar = Vec::new();
        let mut ties = None;
        let mut view = None;
        let mut scale_section = None;
        let mut scale_long = None;

        for p in props {
            match p {
                RawProperty::Cover(c) => cover = Some(c),
                RawProperty::Span(s) => span = Some(s),
                RawProperty::Concrete(c) => concrete = Some(c),
                RawProperty::Rebar(r) => rebar.push(r),
                RawProperty::Ties(t) => ties = Some(t),
                RawProperty::View(v) => view = Some(v),
                RawProperty::Scale(s) => {
                    scale_section = Some(s);
                    scale_long = Some(s);
                },
                RawProperty::ScaleSection(s) => scale_section = Some(s),
                RawProperty::ScaleLong(s) => scale_long = Some(s),
            }
        }

        SectionProperties { shape, cover, span, concrete, rebar, ties, view, scale_section, scale_long }
    }
};

RawProperty: RawProperty = {
    "cover" <n:Num> => RawProperty::Cover(n),
    "span" <n:Num> => RawProperty::Span(n),
    "fc" <n:Num> => RawProperty::Concrete(n),
    <r:RebarEntry> => RawProperty::Rebar(r),
    "ties" <t:StirrupsConfig> => RawProperty::Ties(t),
    "view" <v:ViewType> => RawProperty::View(v),
    "scale" <n:Num> => RawProperty::Scale(n),
    "scale" <n:Num> ":" <m:Num> => RawProperty::Scale(n / m),
    "scale" "section" <n:Num> => RawProperty::ScaleSection(n),
    "scale" "section" <n:Num> ":" <m:Num> => RawProperty::ScaleSection(n / m),
    "scale" "long" <n:Num> => RawProperty::ScaleLong(n),
    "scale" "long" <n:Num> ":" <m:Num> => RawProperty::ScaleLong(n / m),
};

ViewType: View = {
    "section" => View::Section,
    "longitudinal" => View::Longitudinal,
    "both" => View::Both,
};

Shape: Shape = {
    <w:Num> "x" <h:Num> => Shape::Rect { width: w, height: h },
    "D" <d:Num> => Shape::Circle { diameter: d },
};

StirrupsConfig: StirrupsConfig = {
    <s:RebarSize> <d:SpacingItem+> => StirrupsConfig { size: s, dist: d }
};

RebarEntry: RebarEntry = {
    <p:RebarPattern> <c:Num> <s:RebarSize> => RebarEntry {
        pattern: p,
        count: c as u32,
        size: s,
    }
};

RebarPattern: RebarPattern = {
    "top" => RebarPattern::Top,
    "bot" => RebarPattern::Bottom,
    "sides" => RebarPattern::Sides,
    "perim" => RebarPattern::Perimeter,
};

SpacingItem: Spacing = {
    <n:Num> "@" <d:Num> => Spacing::Fixed { count: n as u32, dist: d },
    "rto" "@" <d:Num> => Spacing::Rest { dist: d },
};

// Terminals

RebarSize: String = {
    r"#[0-9]+" => <>.to_string(),
    r#"[0-9]+/[0-9]+""# => <>.to_string(),
    r#"[0-9]+""# => <>.to_string(),
};

StringLiteral: String = {
    r#""[^"]*""# => <>[1..<>.len()-1].to_string()
};

Num: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap()
};

match {
    r"\s*" => {}, // Skip whitespace
    r"//[^\n\r]*[\n\r]*" => {}, // Skip comments
    "beam", "column", "wall",
    "cover", "span", "fc", "ties",
    "top", "bot", "sides", "perim",
    "rto", "view", "section", "longitudinal", "both",
    "x", "D", ":", "@", "{", "}",
    _
}
