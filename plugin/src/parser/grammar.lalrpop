use std::str::FromStr;
use crate::parser::ast::{Section, SectionType, SectionProperties, Shape, RebarEntry, RebarPattern, StirrupsConfig, Spacing, RawProperty};

grammar;

pub Sections: Vec<Section> = {
    <s:Section*> => s
};

Section: Section = {
    <k:SectionType> <id:StringLiteral> ":" "{" <p:Properties> "}" => Section {
        kind: k,
        id: id,
        properties: p,
    }
};

SectionType: SectionType = {
    "beam" => SectionType::Beam,
    "column" => SectionType::Column,
    "wall" => SectionType::Wall,
};

Properties: SectionProperties = {
    <props:RawProperty*> => {
        let mut properties = SectionProperties {
            shape: None,
            cover: None,
            fc: None,
            rebar: Vec::new(),
            ties: None,
        };
        
        let mut current_ties: Option<StirrupsConfig> = None;

        for p in props {
            match p {
                RawProperty::Shape(s) => {
                    properties.shape = Some(s);
                    if let Some(ties) = current_ties.take() { properties.ties = Some(ties); }
                },
                RawProperty::Cover(c) => {
                    properties.cover = Some(c);
                    if let Some(ties) = current_ties.take() { properties.ties = Some(ties); }
                },
                RawProperty::Fc(c) => {
                    properties.fc = Some(c);
                    if let Some(ties) = current_ties.take() { properties.ties = Some(ties); }
                },
                RawProperty::Rebar(r) => {
                    properties.rebar.push(r);
                    if let Some(ties) = current_ties.take() { properties.ties = Some(ties); }
                },
                RawProperty::TiesStart(size) => {
                    if let Some(ties) = current_ties.take() { properties.ties = Some(ties); }
                    current_ties = Some(StirrupsConfig { size, dist: Vec::new() });
                },
                RawProperty::Spacing(s) => {
                    if let Some(ref mut ties) = current_ties {
                        ties.dist.push(s);
                    }
                    // If no ties started, ignore spacing (or error?)
                },
            }
        }
        if let Some(ties) = current_ties { properties.ties = Some(ties); }
        
        properties
    }
};

RawProperty: RawProperty = {
    <s:Shape> => RawProperty::Shape(s),
    "cover" <c:Num> => RawProperty::Cover(c),
    "fc" <c:Num> => RawProperty::Fc(c),
    <r:RebarEntry> => RawProperty::Rebar(r),
    "ties" <s:RebarSize> => RawProperty::TiesStart(s),
    <s:SpacingItem> => RawProperty::Spacing(s),
};

Shape: Shape = {
    <w:Num> "x" <h:Num> => Shape::Rect { width: w, height: h },
    "D" <d:Num> => Shape::Circle { diameter: d },
};

RebarEntry: RebarEntry = {
    <p:RebarPattern> <c:Num> <s:RebarSize> => RebarEntry {
        pattern: p,
        count: c as u32,
        size: s,
    }
};

RebarPattern: RebarPattern = {
    "top" => RebarPattern::Top,
    "bot" => RebarPattern::Bottom,
    "sides" => RebarPattern::Sides,
    "perim" => RebarPattern::Perimeter,
};

SpacingItem: Spacing = {
    <n:Num> "@" <d:Num> => Spacing::Fixed { count: n as u32, dist: d },
    "rto" "@" <d:Num> => Spacing::Rest { dist: d },
};

// Terminals

RebarSize: String = {
    r"#[0-9]+" => <>.to_string(),
    r#"[0-9]+/[0-9]+""# => <>.to_string(),
    r#"[0-9]+""# => <>.to_string(),
};

StringLiteral: String = {
    r#""[^"]*""# => <>[1..<>.len()-1].to_string()
};

Num: f64 = {
    r"[0-9]+(\.[0-9]+)?" => f64::from_str(<>).unwrap()
};

match {
    r"\s*" => {}, // Skip whitespace
    r"//[^\n\r]*[\n\r]*" => {}, // Skip comments
    _
}
